#pragma once

#include "cyk.hpp"

void CYK::WriteProducedBy() {
  for (int32_t index = 0; index < nonterminals_.size(); ++index) {
    for (const auto& rule : rules_[index]) {
      if (rule.size() == 1 && nonterminals_pos_.count(rule[0]) == 0) {
        if (terminals_pos_.count(rule[0]) == 0) {
          terminals_pos_[rule[0]] = terminals_.size();
          terminals_.push_back(rule[0]);
          produced_by_.push_back({});
        }
        produced_by_[terminals_pos_[rule[0]]].push_back(index);
      }
    }
  }
}

void CYK::DoPrecalc() { // called in constructor from Grammar
  Grammar& g = *ptr_g_;
  g.NormalizeToKhomsky();
  nonterminals_ = g.GetNonTerminals();
  rules_ = g.GetRules();
  nonterminals_pos_ = g.GetPos();
  START_NONTERMINAL_ = g.GetStartNonTerminal();
  WriteProducedBy();
  for (auto rule : rules_[nonterminals_pos_[START_NONTERMINAL_]]) {
    if (rule.size() == 0) {
      contains_epsilon_ = true;
    }
  }
}

bool CYK::ContainedInGrammar(const std::string& word) {
  if (contains_epsilon_ && word.empty()) {
    return true;
  }
  std::vector<std::vector<std::vector<bool>>>
       dp(nonterminals_.size(), std::vector<std::vector<bool>>(word.size(), std::vector<bool>(word.size(), false)));
  for (int32_t index = 0; index < word.size(); ++index) {
    for (auto elem : produced_by_[terminals_pos_[word[index]]]) {
      dp[elem][index][index] = true;
    }
  }
  for (int32_t len = 1; len < word.size(); ++len) {
    for (int32_t left = 0; left + len < word.size(); ++left) { // [left ... left + len]
      int32_t right = left + len; // [left ... right]// [left ... border], [border + 1 ... right]
      for (int32_t index = 0; index < nonterminals_.size(); ++index) { // index of nonterminal, which generates [left ... right]
        bool found = false;
        for (int32_t border = left; border < right; ++border) { 
          for (const auto& rule : rules_[index]) { // trying to find rule, which can be generated by nonterminal
            if (found) {
              break;
            }
            if (rule.size() != 2) {
              continue;
            }
            found |= dp[nonterminals_pos_[rule[0]]][left][border] && dp[nonterminals_pos_[rule[1]]][border + 1][right]; 
            if (found) {
              break;
            }
          }
        }
        dp[index][left][right] = found;
      }
    }
  }
  return dp[nonterminals_pos_[START_NONTERMINAL_]][0][word.size() - 1];
}

CYK::CYK(Grammar& g) : Parser(g) {
    DoPrecalc();
}
